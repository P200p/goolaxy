<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Iframe face with load flag and pointer control</title>
<style>
  /* container ของ scene / css-face */
  body, html { height: 100%; margin: 0; background: #0b0b0b; color: #eee; font-family: Inter, system-ui, sans-serif; }
  .stage {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* face wrapper (ตำแหน่งและ transform จะถูกควบคุมจาก THREE CSS3DObject) */
  .css-face {
    width: 420px;            /* ปรับขนาดตามความต้องการ */
    height: 315px;
    position: absolute;
    transform-style: preserve-3d;
    will-change: transform, opacity, visibility;
    display: flex;
    align-items: stretch;
    justify-content: stretch;
    background: transparent;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    overflow: hidden;
    visibility: hidden;     /* เริ่มปิดไว้จนกว่าเงื่อนไขจะพร้อม */
    opacity: 0;
    transition: opacity 200ms linear, visibility 0s linear 200ms;
    pointer-events: none;   /* ปิดไว้เป็นค่าเริ่มต้น JS จะเปิดเมื่อพร้อม */
  }

  /* iframe: ไม่มี pointer-events ใน CSS ให้ JS ควบคุมทั้งหมด */
  .css-face iframe {
    width: 100%;
    height: 100%;
    border: 0;
    display: block;
    background: #111;
  }

  /* placeholder จะแสดงแทน iframe ขณะรอโหลดหรือเมื่อมีปัญหา */
  .placeholder {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg,#111,#151515);
    color: #d9d9d9;
    font-size: 14px;
    gap: 8px;
    padding: 12px;
  }

  .placeholder small { opacity: 0.8; font-size: 12px; }

  /* ปุ่ม retry ธรรมดา */
  .btn {
    background: #0ea5a4;
    color: #042;
    border: none;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
  }

  .status {
    position: absolute;
    left: 12px;
    top: 12px;
    font-size: 12px;
    color: #9aa3b2;
    background: rgba(0,0,0,0.35);
    padding: 6px 8px;
    border-radius: 8px;
    backdrop-filter: blur(6px);
  }

  /* visible state modifier (JS จะเปลี่ยนคลาสหรือ style โดยตรง) */
  .css-face.visible {
    visibility: visible;
    opacity: 1;
    transition: opacity 180ms linear;
    pointer-events: auto; /* ตัว wrapper อนุญาต pointer เมื่อ JS ตัดสินใจ (ต่อด้วย iframe pointer-events) */
  }
</style>
</head>
<body>
  <div class="stage" id="stage">
    <!-- ตัวอย่าง wrapper ที่จะถูกผนวกเข้ากับ CSS3DObject ใน scene ของคุณ
         ถ้าไม่ได้ใช้ THREE CSS3D ให้วาง element นี้ไว้ใน DOM ปกติก็ได้ -->
    <div id="face" class="css-face" role="group" aria-label="3D iframe face">
      <iframe id="theIframe" src="about:blank" title="embedded content" sandbox="allow-scripts allow-same-origin"></iframe>
      <div class="placeholder" id="placeholder">
        <div>
          <div><strong>กำลังโหลดเนื้อหา</strong></div>
          <small id="placeholderMsg">รอ iframe โหลดหรือรอการตอบกลับ</small>
          <div style="margin-top:8px; display:flex; gap:8px;">
            <button id="retryBtn" class="btn">ลองใหม่</button>
            <button id="openBtn" class="btn" style="background:#8b5cf6; color:white;">เปิดในแท็บใหม่</button>
          </div>
        </div>
      </div>
      <div class="status" id="status">state: init</div>
    </div>
  </div>

<script>
/*
  Behavior summary
  - iframeLoaded flag ถูกเซ็ตจาก event load / error และจาก postMessage handshake ถ้า iframe ฝังมาจากแหล่งที่ส่งข้อความได้
  - updateFaceState() จะถูกเรียกทุกเฟรม (หรือทุกครั้งที่สถานะเปลี่ยน) เพื่อคำนวณ visible/pointer-events ตาม dot กับ flag
  - retry logic: กดปุ่ม retry เพื่อโหลดซ้ำ โดยมี retry count และ timeout
  - สามารถใช้ร่วมกับ THREE CSS3DObject โดยเอา element #face ใส่เป็น cssObject.element
*/

/* ปรับค่าเหล่านี้ตามแอปของคุณ */
const IFRAME_URL = 'https://example.com/';   // <-- แก้เป็น URL จริงที่ต้องการฝัง
const LOAD_TIMEOUT_MS = 6000;
const MAX_RETRIES = 3;
const THRESH = 0.35; // dot threshold สำหรับการหันหน้าเข้ากล้อง

/* ตัวแปร global / state */
const faceEl = document.getElementById('face');
const iframe = document.getElementById('theIframe');
const placeholder = document.getElementById('placeholder');
const statusEl = document.getElementById('status');
const retryBtn = document.getElementById('retryBtn');
const openBtn = document.getElementById('openBtn');

let iframeLoaded = false;
let lastLoadAttempt = 0;
let retries = 0;
let loadTimer = null;
let lastMessageOrigin = null; // ถ้าจำเป็นจะตรวจ origin ของ postMessage
let cssObject = null; // ถ้าคุณใช้ THREE CSS3DObject ให้ตั้ง cssObject = new CSS3DObject(faceEl)
let camera = null; // ถ้าคุณมี THREE camera ให้มอบเข้าเพื่อ dot calculation
let visibleByFacing = false; // internal
let visibleByFlag = false;   // internal

/* ตั้งค่า iframe src และเริ่มนับโหลดครั้งแรก */
function startLoad() {
  // ปิดการ interactive ชั่วคราว
  iframeLoaded = false;
  updatePlaceholder('เริ่มโหลด iframe...');
  setStatus('loading');
  clearLoadTimer();

  lastLoadAttempt = Date.now();
  retries++;

  // ให้ src พร้อม query เพื่อบังคับ reload ถ้าจำเป็น
  const cacheBuster = '?_cb=' + Date.now();
  iframe.src = IFRAME_URL + cacheBuster;

  // ตั้ง timeout เพื่อจับกรณี iframe ไม่ตอบหรือถูกบล็อก
  loadTimer = setTimeout(() => {
    // ถ้ายังไม่โหลด ให้ถือว่า fail
    if (!iframeLoaded) {
      setStatus('timeout');
      updatePlaceholder('โหลดเกินเวลา หรือ ถูกบล็อก. ลองกดลองใหม่');
      // เราไม่ auto-retry หลายรอบเพื่อป้องกัน loop; ให้ผู้ใช้กด retry
    }
  }, LOAD_TIMEOUT_MS);
}

/* ล้าง timer */
function clearLoadTimer() {
  if (loadTimer) {
    clearTimeout(loadTimer);
    loadTimer = null;
  }
}

/* event listeners ของ iframe */
iframe.addEventListener('load', () => {
  // แม้ว่า load จะเกิดขึ้น แต่ไม่ได้การันตีว่า content usable (CSP/X-Frame-Options อาจทำให้หน้าแสดง error)
  iframeLoaded = true;
  clearLoadTimer();
  updatePlaceholder('iframe โหลดสำเร็จ');
  setStatus('loaded');
  // ซ่อน placeholder ทันทีและอัปเดตการแสดงผล
  if (placeholder) placeholder.style.display = 'none';
  updateFaceState();
});

iframe.addEventListener('error', () => {
  iframeLoaded = false;
  clearLoadTimer();
  setStatus('error');
  updatePlaceholder('เกิดข้อผิดพลาดระหว่างโหลด iframe');
  if (placeholder) placeholder.style.display = 'flex';
  updateFaceState();
});

/* postMessage handshake (ถ้า iframe origin ส่งข้อความ "ready" จะใช้เป็นสัญญาณว่าพร้อมจริง) */
window.addEventListener('message', (ev) => {
  // ถ้าระบุ origin ที่คาดหวัง ให้ตรวจเช็ก ev.origin เทียบกับ expected origin
  // ตัวอย่างนี้ยอมรับข้อความ "iframe-ready" จากทุก origin เพื่อความยืดหยุ่น
  const data = ev.data;
  if (data && (data === 'iframe-ready' || data.type === 'iframe-ready')) {
    iframeLoaded = true;
    lastMessageOrigin = ev.origin;
    clearLoadTimer();
    updatePlaceholder('iframe ส่งสัญญาณพร้อม');
    setStatus('handshake');
    if (placeholder) placeholder.style.display = 'none';
    updateFaceState();
  }
});

/* ปุ่ม retry และ open */
retryBtn.addEventListener('click', () => {
  if (retries >= MAX_RETRIES) {
    updatePlaceholder('ถึงจำนวน retry สูงสุดแล้ว ลองเปิดในแท็บใหม่');
    return;
  }
  updatePlaceholder('ลองโหลดใหม่...');
  startLoad();
});

openBtn.addEventListener('click', () => {
  window.open(IFRAME_URL, '_blank', 'noopener,noreferrer');
});

/* helper: แสดงข้อความใน placeholder */
function updatePlaceholder(msg) {
  const msgEl = document.getElementById('placeholderMsg');
  if (msgEl) msgEl.textContent = msg;
}

/* helper: อัปเดต status bar */
function setStatus(s) {
  statusEl.textContent = 'state: ' + s + (retries ? ' | attempts ' + retries : '');
}

/* core: คำนวณ visible จากทิศทาง (dot) และ flag iframeLoaded
   - ถ้าคุณใช้ THREE ให้กำหนด cssObject และ camera ให้ตรงกับ scene ของคุณ
   - ถ้าไม่ใช้ THREE คุณสามารถเรียก updateFaceStateVisible(true/false) ตาม logic ของคุณได้ */
function updateFaceState() {
  // ถ้าไม่มี THREE camera หรือ cssObject ให้ fallback: ถ้า iframeLoaded ให้โชว์เสมอ
  if (!cssObject || !camera) {
    visibleByFacing = true;
  } else {
    // คำนวณ dot ระหว่าง forward ของ cssObject กับ vector ไปยัง camera
    const worldPos = new THREE.Vector3();
    cssObject.getWorldPosition(worldPos);

    const worldQuat = new THREE.Quaternion();
    cssObject.getWorldQuaternion(worldQuat);

    const localForward = new THREE.Vector3(0, 0, 1);
    const worldForward = localForward.clone().applyQuaternion(worldQuat).normalize();

    const toCamera = camera.position.clone().sub(worldPos).normalize();
    const dot = worldForward.dot(toCamera);
    visibleByFacing = dot > THRESH;

    // ปรับ opacity เป็น visual cue เมื่อเริ่มหัน (ถ้ามี)
    const opacity = THREE.MathUtils.clamp((dot - THRESH) / (1 - THRESH), 0, 1);
    faceEl.style.opacity = (0.35 + 0.65 * opacity).toString();
  }

  visibleByFlag = !!iframeLoaded;

  const finalVisible = visibleByFacing && visibleByFlag;

  // อัปเดต DOM ตาม finalVisible
  if (finalVisible) {
    faceEl.classList.add('visible');
    faceEl.style.pointerEvents = 'auto';     // wrapper อนุญาต pointer
    iframe.style.pointerEvents = 'auto';     // iframe ให้ interactive
    if (placeholder) placeholder.style.display = 'none';
    setStatus('interactive');
  } else {
    faceEl.classList.remove('visible');
    faceEl.style.pointerEvents = 'none';
    iframe.style.pointerEvents = 'none';
    if (!iframeLoaded) {
      // ถ้ายังไม่โหลด แสดง placeholder
      if (placeholder) placeholder.style.display = 'flex';
    }
    setStatus('inactive');
  }
}

/* animate loop หากใช้ THREE รันแยกหรือรวมกับ render loop ของคุณ
   ตัวอย่างนี้รัน updateFaceState ทุกเฟรม แต่คุณอาจเรียกมันเฉพาะเมื่อ camera เคลื่อนก็ได้ */
function animateLoop() {
  // ถ้าคุณมี THREE render loop ให้เอา updateFaceState() ไว้ก่อน render
  updateFaceState();
  requestAnimationFrame(animateLoop);
}
requestAnimationFrame(animateLoop);

/* เริ่มโหลดครั้งแรก */
startLoad();

/* Exports สำหรับ integration: ให้คุณตั้ง cssObject และ camera จากภายนอกได้ */
window.__FaceControl = {
  setCssObject(obj) { cssObject = obj; },
  setCamera(cam) { camera = cam; },
  forceShow() { iframeLoaded = true; updateFaceState(); },
  forceHide() { iframeLoaded = false; updateFaceState(); },
  reloadIframe() { startLoad(); }
};
</script>
</body>
</html>
