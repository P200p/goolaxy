<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Three + CSS3D iframe integration (Orbit safe)</title>
<style>
  :root { --bg:#0b0b0b; --muted:#9aa3b2; --accent:#0ea5a4; }
  html,body { height:100%; margin:0; background:var(--bg); color:#e9eef6; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial; }
  #app { position:relative; width:100%; height:100%; overflow:hidden; }

  /* WebGL canvas */
  canvas#three-canvas {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
    touch-action:none;
    pointer-events:auto; /* ให้ canvas รับ pointer events เป็นดีฟอลต์ */
  }

  /* CSS3D container is positioned absolute above canvas */
  .css3d-root {
    position:absolute;
    inset:0;
    pointer-events:none; /* default none, individual faces control pointer-events */
  }

  /* face wrapper (will be used as CSS3DObject.element) */
  .css-face {
    width:420px;
    height:315px;
    border-radius:12px;
    overflow:hidden;
    background:linear-gradient(180deg,#0f1720,#0b1220);
    box-shadow:0 10px 40px rgba(0,0,0,0.6);
    transform-style:preserve-3d;
    will-change:transform,opacity,visibility;
    pointer-events:none; /* closed by default so canvas keeps events */
    visibility:hidden;
    opacity:0;
    transition:opacity 180ms linear, visibility 0s linear 180ms;
  }

  .css-face.visible {
    visibility:visible;
    opacity:1;
    pointer-events:auto; /* wrapper allows pointer when visible; iframe still controlled */
  }

  .css-face iframe {
    width:100%;
    height:100%;
    border:0;
    display:block;
    background:#071018;
    pointer-events:none; /* JS toggles this to 'auto' only when interactive */
  }

  .placeholder {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    color:#cbd5e1;
    gap:8px;
    padding:12px;
    text-align:center;
    background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.45));
    font-size:13px;
  }

  .controls-ui {
    position: absolute;
    right: 12px;
    top: 12px;
    display:flex;
    gap:8px;
    align-items:center;
    z-index:30;
  }

  .btn {
    background:var(--accent);
    color:#042;
    border:none;
    padding:8px 10px;
    border-radius:8px;
    font-weight:600;
    cursor:pointer;
  }

  .status {
    position:absolute;
    left:12px;
    top:12px;
    font-size:12px;
    color:var(--muted);
    background:rgba(0,0,0,0.35);
    padding:6px 8px;
    border-radius:8px;
    backdrop-filter: blur(6px);
    z-index:20;
  }

  footer.note {
    position:absolute;
    left:12px;
    bottom:12px;
    color:var(--muted);
    font-size:12px;
    z-index:20;
  }
</style>
</head>
<body>
  <div id="app">
    <canvas id="three-canvas"></canvas>
    <div class="css3d-root" id="css3d-root"></div>

    <div class="controls-ui">
      <button id="reloadBtn" class="btn">Reload iframe</button>
      <button id="forceBtn" class="btn" style="background:#8b5cf6;color:white">Force interactive</button>
    </div>
    <div class="status" id="status">state: init</div>
    <footer class="note">Demo: OrbitControls kept while iframe inactive; iframe interactive only when ready</footer>
  </div>

<script type="module">
/*--------------
  Minimal module setup: Three, OrbitControls, CSS3DRenderer via unpkg CDN (ES module)
  If you need non-module, swap to UMD scripts; this demo uses module imports.
--------------*/
import * as THREE from 'https://unpkg.com/three@0.156.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.156.0/examples/jsm/controls/OrbitControls.js';
import { CSS3DRenderer, CSS3DObject } from 'https://unpkg.com/three@0.156.0/examples/jsm/renderers/CSS3DRenderer.js';

/* ------------- Config ------------- */
const IFRAME_URL = 'https://goonee.netlify.app/'; // <<< แก้เป็น URL ที่ต้องการฝัง
const THRESH = 0.35;
const LOAD_TIMEOUT_MS = 6000;

/* ------------- DOM refs ------------- */
const canvas = document.getElementById('three-canvas');
const cssRoot = document.getElementById('css3d-root');
const statusEl = document.getElementById('status');
const reloadBtn = document.getElementById('reloadBtn');
const forceBtn = document.getElementById('forceBtn');

/* ------------- Three scene ------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x071020);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 1.6, 3);

const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight, false);

const cssRenderer = new CSS3DRenderer();
cssRenderer.setSize(window.innerWidth, window.innerHeight);
cssRenderer.domElement.style.position = 'absolute';
cssRenderer.domElement.style.top = '0';
cssRenderer.domElement.style.left = '0';
cssRenderer.domElement.style.pointerEvents = 'none'; // let DOM elements control events
cssRoot.appendChild(cssRenderer.domElement);

/* orbit */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

/* simple scene content: cube for reference */
const geo = new THREE.BoxGeometry(1,1,1);
const mat = new THREE.MeshStandardMaterial({ color:0x0ea5a4, roughness:0.6, metalness:0.0 });
const cube = new THREE.Mesh(geo, mat);
cube.position.set(-1.2, 1.0, 0);
scene.add(cube);

const light = new THREE.DirectionalLight(0xffffff, 1.0);
light.position.set(5,10,7);
scene.add(light);

/* ------------- CSS3D face setup (iframe wrapper) ------------- */
const faceEl = document.createElement('div');
faceEl.className = 'css-face';
faceEl.setAttribute('role','group');
faceEl.setAttribute('aria-hidden','true');

/* inner iframe and placeholder */
const iframe = document.createElement('iframe');
iframe.id = 'theIframe';
iframe.title = 'embedded content';
iframe.sandbox = 'allow-scripts allow-same-origin';
iframe.src = 'about:blank';

const placeholder = document.createElement('div');
placeholder.className = 'placeholder';
placeholder.innerHTML = '<div><strong>รอโหลด iframe</strong><div style="margin-top:6px"><small id="placeholderMsg">initializing</small></div></div>';

faceEl.appendChild(iframe);
faceEl.appendChild(placeholder);

/* create CSS3DObject and position it in world */
const cssObject = new CSS3DObject(faceEl);
cssObject.position.set(0, 1.4, 0); // ปรับตำแหน่งในโลกสามมิติ
// rotate the face to face +Z by default (no rotation needed)
scene.add(new THREE.Object3D()); // placeholder if needed
scene.add(cssObject);

/* scale: map face px to size (approx). CSS3D uses px => 1 unit mapping,
   scale so face visually matches 3D units. Tweak CSS_FACE_PX to change. */
const CSS_FACE_PX = 420; // width in px
const CUBE_SIZE = 1.2; // target 3D width
const scaleFactor = CUBE_SIZE / CSS_FACE_PX;
cssObject.scale.setScalar(scaleFactor);

/* ------------- state & logic ------------- */
let iframeLoaded = false;
let loadTimer = null;
let retries = 0;
let lastMessageOrigin = null;

/* helper status */
function setStatus(s) { statusEl.textContent = 'state: ' + s + (retries ? ' | attempts ' + retries : ''); }

/* load management */
function startLoad() {
  iframeLoaded = false;
  retries++;
  setStatus('loading');
  placeholder.style.display = 'flex';
  document.getElementById('placeholderMsg').textContent = 'กำลังโหลด iframe...';
  clearTimeout(loadTimer);
  // cache-bust to force reload
  iframe.src = IFRAME_URL + (IFRAME_URL.includes('?') ? '&' : '?') + '_cb=' + Date.now();
  loadTimer = setTimeout(() => {
    if (!iframeLoaded) {
      setStatus('timeout');
      document.getElementById('placeholderMsg').textContent = 'โหลดเกินเวลา หรือ ถูกบล็อก';
      // keep placeholder visible; user can reload manually
      updateFaceState();
    }
  }, LOAD_TIMEOUT_MS);
}

iframe.addEventListener('load', () => {
  // note: load may fire even if content is blocked; we still tentatively mark loaded
  iframeLoaded = true;
  clearTimeout(loadTimer);
  document.getElementById('placeholderMsg').textContent = 'iframe โหลดสำเร็จ';
  placeholder.style.display = 'none';
  setStatus('loaded');
  updateFaceState();
});

iframe.addEventListener('error', () => {
  iframeLoaded = false;
  clearTimeout(loadTimer);
  document.getElementById('placeholderMsg').textContent = 'เกิดข้อผิดพลาดขณะโหลด';
  placeholder.style.display = 'flex';
  setStatus('error');
  updateFaceState();
});

/* optional postMessage handshake: if embedded page sends 'iframe-ready' we trust it */
window.addEventListener('message', (ev) => {
  const d = ev.data;
  if (d === 'iframe-ready' || (d && d.type === 'iframe-ready')) {
    iframeLoaded = true;
    lastMessageOrigin = ev.origin;
    clearTimeout(loadTimer);
    document.getElementById('placeholderMsg').textContent = 'iframe ส่งสัญญาณ ready';
    placeholder.style.display = 'none';
    setStatus('handshake');
    updateFaceState();
  }
});

/* core: compute facing using cssObject transform and camera, then combine with iframeLoaded flag */
function updateFaceState() {
  // compute facing
  let visibleByFacing = true;
  try {
    const worldPos = new THREE.Vector3();
    cssObject.getWorldPosition(worldPos);
    const worldQuat = new THREE.Quaternion();
    cssObject.getWorldQuaternion(worldQuat);
    const localForward = new THREE.Vector3(0,0,1).applyQuaternion(worldQuat).normalize();
    const toCamera = camera.position.clone().sub(worldPos).normalize();
    const dot = localForward.dot(toCamera);
    visibleByFacing = dot > THRESH;
    // visual cue
    const opacity = THREE.MathUtils.clamp((dot - THRESH) / (1 - THRESH), 0, 1);
    faceEl.style.opacity = (0.35 + 0.65 * opacity).toString();
  } catch(e) {
    visibleByFacing = true;
  }

  const finalVisible = visibleByFacing && iframeLoaded;

  const threeCanvas = renderer.domElement;

  if (finalVisible) {
    faceEl.classList.add('visible');
    faceEl.style.pointerEvents = 'auto';   // wrapper allows pointer
    iframe.style.pointerEvents = 'auto';   // iframe interactive
    // prevent canvas from receiving pointer while iframe interactive
    if (threeCanvas) threeCanvas.style.pointerEvents = 'none';
    faceEl.setAttribute('aria-hidden','false');
    setStatus('interactive');
  } else {
    faceEl.classList.remove('visible');
    faceEl.style.pointerEvents = 'none';
    iframe.style.pointerEvents = 'none';
    if (threeCanvas) threeCanvas.style.pointerEvents = 'auto';
    if (!iframeLoaded) placeholder.style.display = 'flex';
    faceEl.setAttribute('aria-hidden','true');
    setStatus('inactive');
  }
}

/* ------------- UI bindings ------------- */
reloadBtn.addEventListener('click', () => {
  startLoad();
});
forceBtn.addEventListener('click', () => {
  iframeLoaded = true;
  placeholder.style.display = 'none';
  updateFaceState();
});

/* ------------- render loop ------------- */
function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  cssRenderer.setSize(window.innerWidth, window.innerHeight);
}
window.addEventListener('resize', onWindowResize, false);

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  updateFaceState();
  renderer.render(scene, camera);
  cssRenderer.render(scene, camera);
}
animate();

/* start initial load */
startLoad();

/* expose integration helpers */
window.__FaceIntegration = {
  cssObject, // initial reference (if you change it externally, replace)
  setCssObject(obj) { cssObject = obj; },
  setCamera(cam) { /* not used: camera is internal here */ },
  reload() { startLoad(); },
  forceInteractive() { iframeLoaded = true; updateFaceState(); }
};
</script>
</body>
</html>
