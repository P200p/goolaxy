<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cyber Holo Orbit</title>
  <style>
    /* ---- original site styles ---- */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient( circle at center, rgba(0, 0, 0, 0.1) 50%, rgba(5, 0, 20, 1) 100% ), url("./images/bg.png") no-repeat center center / cover;
      background-color: #050010;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    /* SVG Overlay HUD */
    #edgeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      mix-blend-mode: screen;
    }
    @keyframes glowPulse { 0% { opacity: 0.2; } 100% { opacity: 0.5; } }
    #edgeOverlay rect { animation: glowPulse 3s infinite alternate; }
    .center-ring {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 400px;
      height: 400px;
      transform: translate(-50%, -50%);
      animation: rotate 12s linear infinite;
      opacity: 0.35;
      z-index: 3;
    }
    @keyframes rotate { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

    /* Navigation button */
    .nav-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(26, 26, 46, 0.9);
      color: #00ffff;
      padding: 15px 20px;
      border: 2px solid #00ffff;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      z-index: 1000;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }
    .nav-button:hover { background: #00ffff; color: #1a1a2e; transform: scale(1.05); }

    /* ---- cube styles (new) ---- */
    :root {
      /* make faces physically large */
      --face-w: 960px;
      --face-h: 540px;
      /* face spacing (used for translateZ on faces) */
      --cube-translate: calc(var(--face-w) / 2);
      /* how far to push the whole cube away (negative Z -> away from camera) */
      --cube-distance: -900px;
    }

    /* stage positions the cube within the scene but we keep it pointer-events enabled
       so users can interact; place it off-center so players must move toward it */
    .cube-stage {
      position: fixed;
      left: 50%;
      top: 10%;
      width: calc(var(--face-w) + 80px);
      height: calc(var(--face-h) + 80px);
      display: flex;
      align-items: center;
      justify-content: center;
      perspective: 1400px;
      z-index: 850;
      pointer-events: auto;
      transform: translateX(-50%);
      /* optional faint hint outline */
      -webkit-tap-highlight-color: transparent;
    }

    /* wrap: we translate the whole cube away so it appears smaller/remote,
       while keeping face sizes large so when user approaches it becomes prominent */
    .cube-wrap {
      width: var(--face-w);
      height: var(--face-h);
      transform-style: preserve-3d;
      /* translateZ moves entire cube along Z axis; negative pushes away */
      transform: translateZ(var(--cube-distance)) rotateX(-12deg) rotateY(22deg);
      transition: transform 420ms cubic-bezier(.2,.9,.2,1);
      position: relative;
      will-change: transform;
      pointer-events: auto;
    }

    .cube-face {
      position: absolute;
      left: 50%;
      top: 50%;
      width: var(--face-w);
      height: var(--face-h);
      transform-origin: center center;
      backface-visibility: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.25));
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 18px 60px rgba(0,0,0,0.6);
      box-sizing: border-box;
      transform: translate(-50%, -50%);
      overflow: hidden;
      font-family: system-ui, "Segoe UI", Roboto, sans-serif;
      font-size: 16px;
    }

    /* subtle visual frame so dev/test can see where cube is (lower opacity for production) */
    .cube-face::after {
      content: "";
      position: absolute;
      inset: 0;
      border: 1px dashed rgba(255,255,255,0.02);
      pointer-events: none;
    }

    /* explicit transforms for 6 faces (use large translateZ matching face width) */
    .face-front  { transform: translate(-50%, -50%) translateZ(var(--cube-translate)); }
    .face-back   { transform: translate(-50%, -50%) rotateY(180deg) translateZ(var(--cube-translate)); }
    .face-right  { transform: translate(-50%, -50%) rotateY(90deg) translateZ(var(--cube-translate)); }
    .face-left   { transform: translate(-50%, -50%) rotateY(-90deg) translateZ(var(--cube-translate)); }
    .face-top    { transform: translate(-50%, -50%) rotateX(90deg) translateZ(calc(var(--face-h) / 2)); }
    .face-bottom { transform: translate(-50%, -50%) rotateX(-90deg) translateZ(calc(var(--face-h) / 2)); }

    /* face content placeholder */
    .face-content {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.25);
      color: #cbd5e1;
      text-align: center;
      padding: 12px;
    }

    /* small UI controls overlay (kept minimal) */
    .cube-controls {
      position: absolute;
      right: -14px;
      top: -14px;
      display: flex;
      gap: 8px;
      z-index: 1100;
    }
    .cube-controls button {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.06);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
    }

    /* responsive: keep the cube distance proportional on small screens */
    @media (max-width: 1200px) {
      :root { --cube-distance: -700px; }
    }
    @media (max-width: 900px) {
      :root { --face-w: 560px; --face-h: 315px; --cube-translate: calc(var(--face-w) / 2); --cube-distance: -600px; }
      .cube-stage { top: 6%; }
    }
    @media (max-width: 420px) {
      :root { --face-w: 360px; --face-h: 202px; --cube-translate: calc(var(--face-w) / 2); --cube-distance: -420px; }
      .cube-stage { top: 4%; left: 50%; transform: translateX(-50%); width: calc(var(--face-w) + 40px); height: calc(var(--face-h) + 40px); }
    }
  </style>
</head>
<body>
  <!-- Three.js Canvas (original) -->
  <canvas id="threeCanvas"></canvas>

  <!-- Nav to Cube (original) -->
  <a href="./cube.html" class="nav-button">üåê 3D Web Portal</a>

  <!-- ---- cube markup (new) ---- -->
  <div class="cube-stage" aria-hidden="false" title="Distant ad cube">
    <div class="cube-wrap" id="cubeWrap" role="application" aria-label="Distant big cube ad">
      <div class="cube-face face-front" data-face="front">
        <div class="face-content">Ad: Front</div>
      </div>
      <div class="cube-face face-back" data-face="back">
        <div class="face-content">Ad: Back</div>
      </div>
      <div class="cube-face face-right" data-face="right">
        <div class="face-content">Ad: Right</div>
      </div>
      <div class="cube-face face-left" data-face="left">
        <div class="face-content">Ad: Left</div>
      </div>
      <div class="cube-face face-top" data-face="top">
        <div class="face-content">Ad: Top</div>
      </div>
      <div class="cube-face face-bottom" data-face="bottom">
        <div class="face-content">Ad: Bottom</div>
      </div>
    </div>

    <!-- controls (optional) -->
    <div class="cube-controls" aria-hidden="true">
      <button id="cubeAuto">Auto</button>
      <button id="cubeReset">Reset</button>
    </div>
  </div>

  <!-- original script include -->
  <script type="module" src="./src/main.js"></script>

  <!-- cube behaviour script (minimal, non-intrusive) -->
  <script>
    (function(){
      const cube = document.getElementById('cubeWrap');
      if (!cube) return;
      // initial rotation and a small zoom-in on hover behavior
      let rx = -12, ry = 22;
      function apply() { cube.style.transform = `translateZ(var(--cube-distance)) rotateX(${rx}deg) rotateY(${ry}deg)`; }
      apply();

      // simple drag to rotate
      let dragging = false, lastX = 0, lastY = 0;
      cube.addEventListener('pointerdown', (e) => {
        dragging = true;
        lastX = e.clientX; lastY = e.clientY;
        cube.setPointerCapture?.(e.pointerId);
      });
      window.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - lastX, dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        ry += dx * 0.22;
        rx -= dy * 0.18;
        rx = Math.max(-90, Math.min(90, rx));
        apply();
      });
      window.addEventListener('pointerup', () => { dragging = false; });

      // small hover zoom to hint interactivity (scale cube slightly when pointer is over stage)
      const stage = document.querySelector('.cube-stage');
      stage.addEventListener('pointerenter', () => {
        cube.style.transition = 'transform 320ms cubic-bezier(.2,.9,.2,1)';
        cube.style.transform = `translateZ(calc(var(--cube-distance) + 120px)) rotateX(${rx}deg) rotateY(${ry}deg)`;
      });
      stage.addEventListener('pointerleave', () => {
        cube.style.transform = `translateZ(var(--cube-distance)) rotateX(${rx}deg) rotateY(${ry}deg)`;
      });

      // auto rotate toggle
      let auto = false, rafId = 0;
      document.getElementById('cubeAuto').addEventListener('click', () => {
        auto = !auto;
        if (auto) { rafId = requestAnimationFrame(loop); document.getElementById('cubeAuto').textContent = 'Stop'; }
        else { cancelAnimationFrame(rafId); document.getElementById('cubeAuto').textContent = 'Auto'; }
      });
      function loop() { ry += 0.35; apply(); rafId = requestAnimationFrame(loop); }

      // reset
      document.getElementById('cubeReset').addEventListener('click', () => {
        rx = -12; ry = 22; apply();
      });

      // accessibility: allow arrow keys
      window.addEventListener('keydown', (e) => {
        const step = 10;
        if (e.key === 'ArrowLeft') ry -= step;
        if (e.key === 'ArrowRight') ry += step;
        if (e.key === 'ArrowUp') rx -= step;
        if (e.key === 'ArrowDown') rx += step;
        apply();
      });
    })();
  </script>
</body>
</html>
